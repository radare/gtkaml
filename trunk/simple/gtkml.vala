/* gtkml parser -- Copyleft 2010 -- author: pancake<nopcode.org> */

int tok_idx = 0;
string tokens[64];
private bool ignorelast;
GtkmlTokenType last_type = GtkmlTokenType.INVALID;

private static void pushtoken (string token) {
	if (tok_idx>=tokens.length)
		error ("Cannot push more tokens");
	//print (">> [%d]=%s\n", tok_idx, token);
	tokens[tok_idx++] = token;
}

private static string poptoken () {
	if (tok_idx == 0)
		return "";
	//	error ("Cannot pop more tokens");
	//print ("<< [%d]=%s\n", tok_idx-1, tokens[tok_idx-1]);
	return tokens[--tok_idx];
}

public enum GtkmlTokenType {
	CODE,
	CLASS,
	COMMENT_LINE,
	COMMENT_BLOCK,
	ATTRIBUTE,
	BEGIN,
	END,
	INVALID
}

[Compact]
public class GtkmlToken {
	public string str;
	public GtkmlTokenType type;

	private inline bool is_separator (uchar ch) {
		switch (ch) {
		case ' ':
		case '\t':
		case ',':
		case '\n':
		case '\r':
		case '\0':
			return true;
		}
		return false;
	}

	private void skip_spaces(DataInputStream dis) throws Error {
		for (;;) {
			var ch = dis.read_byte ();
			if (!is_separator (ch)) {
				update (ch);
				break;
			}
		}
	}

	public GtkmlToken(DataInputStream? dis = null) throws Error {
		str = "";
		type = GtkmlTokenType.CLASS;
		if (dis != null) {
			skip_spaces (dis);
			while (update (dis.read_byte ()));
		}
	}

	public bool update (uchar ch) {
		switch (type) {
		case GtkmlTokenType.COMMENT_LINE:
			if (ch == '\n' || ch == '\r') 
				return false;
			str += "%c".printf (ch);
			return true;
		case GtkmlTokenType.COMMENT_BLOCK:
			str += "%c".printf (ch);
			if (str.has_suffix ("*/")) {
				str = str[0:str.length-2];
				return false;
			}
			return true;
		case GtkmlTokenType.CODE:
			str += "%c".printf (ch);
			if (str.has_suffix ("}-")) {
				str = str[0:str.length-2];
				return false;
			}
			return true;
		}
		if (is_separator (ch))
			return false;
		switch (ch) {
		case ':':
			if (str.str ("=") == null)
				type = GtkmlTokenType.CLASS;
			if (last_type == GtkmlTokenType.CLASS)
				type = GtkmlTokenType.ATTRIBUTE;
			break;
		case '=':
			type = GtkmlTokenType.ATTRIBUTE;
			break;
		case '{':
			if (str == "-") {
				type = GtkmlTokenType.CODE;
				str = "";
				return true;
			} else type = GtkmlTokenType.BEGIN;
			return false;
		case ';':
			ignorelast = (type!=GtkmlTokenType.CLASS);
			return false;
		case '}':
			type = GtkmlTokenType.END;
			return false;
		}
		str += "%c".printf (ch);
		if (str == "//") {
			type = GtkmlTokenType.COMMENT_LINE;
			str = "";
		}
		if (str == "/*") {
			type = GtkmlTokenType.COMMENT_BLOCK;
			str = "";
		}
		return true;
	}

	public string to_xml() {
		var eos = "";
		var bos = "";
		if (ignorelast) {
			poptoken ();
			eos = " />\n";
			ignorelast = false;
		}
		int max = tok_idx;
		if (type == GtkmlTokenType.END)
			max--;
		for (int i = 0; i<max; i++)
			bos += "  ";
		switch (type) {
		case GtkmlTokenType.CLASS:
			pushtoken (str);
			return bos+"<"+str+eos;
		case GtkmlTokenType.COMMENT_BLOCK:
		case GtkmlTokenType.COMMENT_LINE:
			return bos+"<!-- "+str+" -->\n";
		case GtkmlTokenType.BEGIN:
			return ">\n";
		case GtkmlTokenType.END:
			string node = poptoken ();
			if (last_type == GtkmlTokenType.CLASS)
				bos =">";
			return bos+"</"+node+">\n";
		case GtkmlTokenType.ATTRIBUTE:
			if (str == "gtkml:root")
				return " xmlns:gtkaml=\"http://gtkaml.org/0.1\" xmlns=\"Gtk\"";
			var foo = str.split ("=");
			if (foo.length != 2)
				error ("Missing value in attribute '%s'", str);
			var val = foo[1];
			if (val[0] == '"') {
				if (val[val.length-1] != '"')
					error ("Missing '\"' in attribute '%s'", str);
				val = val[1:val.length-1];
			}
			return " "+foo[0]+"=\""+val+"\""+eos;
		case GtkmlTokenType.CODE:
			var pre = "";
			if (last_type== GtkmlTokenType.END) {
				string node = poptoken ();
				if (last_type == GtkmlTokenType.CLASS)
					bos =">";
				pre = bos+"</"+node+">\n";
			}
			return pre+bos+"<![CDATA[\n"+str+"\n"+bos+"]]>\n";
		}
		return "<!-- XXX ("+str+") -->";
	}
}

public class GtkmlTranslator {
	StringBuilder xmlstr = null;

	public GtkmlTranslator() {
	}

	public void parse_file(string filename) {
		xmlstr = new StringBuilder ();
		var file = File.new_for_path (filename);

		if (!file.query_exists ())
			error ("File '%s' doesn't exist.", filename);

		GtkmlToken? token = null;
		try {
			var dis = new DataInputStream (file.read ());
			for (;;) {
				token = new GtkmlToken (dis);
				xmlstr.append (token.to_xml ());
				last_type = token.type;
			}
		} catch (Error e) {
			if (e.code != 0)
				error ("%s", e.message);
		}
	}

	public void to_file(string filename) {
		if (xmlstr == null)
			error ("no file parsed");
		var file = File.new_for_path (filename);
		try {
			var dos = new DataOutputStream (file.create (FileCreateFlags.NONE));
			dos.put_string ("<!-- automatically generated by gtkml -->\n");
			dos.put_string (xmlstr.str);
		} catch (Error e) {
			error ("%s", e.message);
		}
	}

	public string to_string() {
		return (xmlstr!=null)? xmlstr.str: "";
	}
}

void main(string[] args) {
	if (args.length>1) {
		var gt = new GtkmlTranslator ();
		foreach (unowned string file in args[1:args.length]) {
			if (!file.has_suffix (".gtkml"))
				error ("Unsupported file format for "+file+"\n");
			gt.parse_file (file);
			gt.to_file (file.replace (".gtkml", ".gtkaml"));
		}
	} else print ("gtkml [file.gtkml ...]\n");
}
